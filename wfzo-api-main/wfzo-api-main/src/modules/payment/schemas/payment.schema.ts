import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose";
import { HydratedDocument } from "mongoose";

export type PaymentDocument = HydratedDocument<Payment>;

export type PaymentStatus = "pending" | "processing" | "paid" | "failed" | "refunded" | "partially_refunded" | "cancelled";
export type PaymentType = "membership" | "event_registration" | "subscription" | "other";

/**
 * Payment gateway response details
 * Stores raw response from payment gateway for audit and debugging
 */
@Schema({ _id: false })
export class GatewayResponse {
  @Prop({ required: false })
  gatewayName?: string;

  @Prop({ type: Object, required: false })
  createPaymentLinkResponse?: Record<string, any>; // Store complete response from create payment link

  @Prop({ type: Object, required: false })
  paymentResult?: Record<string, any>; // PayTabs payment_result object (response_status, response_message, etc.)
}

const GatewayResponseSchema = SchemaFactory.createForClass(GatewayResponse);

/**
 * Refund information
 */
@Schema({ _id: false })
export class RefundInfo {
  @Prop({ required: true })
  refundId!: string;

  @Prop({ required: true, type: Number })
  amount!: number;

  @Prop({ required: true })
  currency!: string;

  @Prop({ required: false })
  reason?: string;

  @Prop({ type: Object, required: false })
  gatewayResponse?: Record<string, any>;

  @Prop({ type: Date, required: true })
  refundedAt!: Date;

  @Prop({ required: false })
  refundedBy?: string; // User ID or admin ID who initiated refund
}

const RefundInfoSchema = SchemaFactory.createForClass(RefundInfo);

/**
 * Payment schema for storing payment information
 * Supports multiple payment types: membership, event registration, etc.
 */
@Schema({ timestamps: true, collection: "payments" })
export class Payment {
  /**
   * Unique payment identifier
   * Format: PAY-001, PAY-002, etc. or UUID
   * Auto-generated by pre-save hook, so not required in schema
   */
  @Prop({ type: String, required: false, unique: true, index: true })
  paymentId!: string;

  /**
   * Payment type - what this payment is for
   */
  @Prop({ required: true, enum: ["membership", "event_registration", "subscription", "other"] })
  paymentType!: PaymentType;

  /**
   * Reference to the entity this payment is for
   * e.g., memberId, eventId, registrationId, etc.
   */
  @Prop({ type: String, required: true, index: true })
  entityId!: string;

  /**
   * Entity type for better querying
   * e.g., "member", "event", "registration"
   */
  @Prop({ type: String, required: true, index: true })
  entityType!: string;

  /**
   * Payment amount
   */
  @Prop({ type: Number, required: true })
  amount!: number;

  /**
   * Currency code (ISO 4217)
   * e.g., "AED", "USD", "EUR", "GBP"
   */
  @Prop({ type: String, required: true, default: "AED" })
  currency!: string;

  /**
   * Payment status
   */
  @Prop({
    required: true,
    enum: ["pending", "processing", "paid", "failed", "refunded", "partially_refunded", "cancelled"],
    default: "pending",
    index: true,
  })
  status!: PaymentStatus;

  /**
   * Gateway transaction reference (tran_ref)
   */
  @Prop({ type: String, required: false, index: true })
  gatewayTransactionId?: string;

  /**
   * Payment link (if applicable)
   * Used for generating payment links that users can access
   */
  @Prop({ type: String, required: false })
  paymentLink?: string;

  /**
   * Payment link expiration timestamp
   * Payment link expires after this time (typically 20 minutes from creation)
   */
  @Prop({ type: Date, required: false, index: true })
  paymentLinkExpiresAt?: Date;

  /**
   * Payment gateway response details
   */
  @Prop({ type: GatewayResponseSchema, required: false })
  gatewayResponse?: GatewayResponse;

  /**
   * Refund information (if payment was refunded)
   */
  @Prop({ type: [RefundInfoSchema], default: [] })
  refunds?: RefundInfo[];

  /**
   * Payment reference ID from payment gateway (ORDER_10005, etc.)
   * This is the unique identifier used by the payment gateway for this payment request
   */
  @Prop({ type: String, required: false, index: true })
  paymentReferenceId?: string;

  /**
   * Soft delete timestamp
   */
  @Prop({ type: Date, default: null })
  deletedAt?: Date | null;

  createdAt?: Date;
  updatedAt?: Date;
}

export const PaymentSchema = SchemaFactory.createForClass(Payment);

// Add indexes for common queries
PaymentSchema.index({ entityId: 1, entityType: 1, status: 1 });
PaymentSchema.index({ paymentType: 1, status: 1 });
PaymentSchema.index({ createdAt: -1 });
PaymentSchema.index({ paymentId: 1 }, { unique: true });
PaymentSchema.index({ paymentReferenceId: 1 });
PaymentSchema.index({ gatewayTransactionId: 1 });

/**
 * Pre-save hook to auto-generate paymentId
 * Format: PAY-001, PAY-002, etc.
 */
PaymentSchema.pre("save", async function (next) {
  // Only generate ID if it's a new document and paymentId is not already set
  if (this.isNew && !this.paymentId) {
    try {
      const Counter = this.db.model("Counter");

      const paymentCounter = await Counter.findOneAndUpdate(
        { name: "payment" },
        { $inc: { seq: 1 } },
        { new: true, upsert: true },
      );

      if (!paymentCounter || typeof paymentCounter.seq !== "number") {
        throw new Error("Failed to generate payment ID");
      }

      this.paymentId = `PAY-${String(paymentCounter.seq).padStart(3, "0")}`;

      next();
    } catch (error) {
      next(error as Error);
    }
  } else {
    next();
  }
});

