import {
  Injectable,
  Logger,
  BadRequestException,
  InternalServerErrorException,
  Inject,
  forwardRef,
  NotFoundException,
} from "@nestjs/common";
import { PaymentRepository } from "./repository/payment.repository";
import { PaytabPaymentGatewayService } from "./services/paytab-payment-gateway.service";
import {
  CreatePaymentDto,
  PaymentResponseDto,
  RefundPaymentDto,
} from "./dto/payment.dto";
import { Payment, PaymentStatus, PaymentType } from "./schemas/payment.schema";
import { v4 as uuid } from "uuid";
import { Member } from "@modules/member/schemas/member.schema";
import { WorkflowOrchestrator } from "@modules/member/workflow/services/workflow-orchestrator.service";

@Injectable()
export class PaymentService {
  private readonly logger = new Logger(PaymentService.name);

  constructor(
    private readonly paymentRepository: PaymentRepository,
    private readonly gatewayService: PaytabPaymentGatewayService,
    @Inject(forwardRef(() => WorkflowOrchestrator))
    private readonly workflowOrchestrator: WorkflowOrchestrator,
  ) { }

  /**
   * Create a payment link
   * 1. Fetches member details
   * 2. Checks if payment with same paymentReferenceId already exists (returns existing if found)
   * 3. Calls gateway service to create payment link (handles all gateway-specific logic)
   * 4. Creates payment record in database
   * 5. Updates payment record with gateway response and returns payment link
   */
  async createPaymentLink(dto: CreatePaymentDto): Promise<PaymentResponseDto> {
    const entityType = dto.entityType;
    const entity = dto.entity;
    const entityId = dto.entityId;
    const currency = dto.currency;
    const amount = dto.amount;
    try {
      this.logger.log(`Creating payment link for member: ${entityId}`);

      // Generate payment reference ID
      const paymentReferenceId = `ORDER_${entityType.toUpperCase()}_${entityId}`;
      const paymentType = this.determinePaymentType(entityType);

      // Check if payment with same paymentReferenceId already exists
      const existingPayment = await this.paymentRepository.findByPaymentReferenceId(paymentReferenceId);
      if (existingPayment && existingPayment.paymentLink && existingPayment.status !== "failed") {
        // Check if payment link is expired
        if (this.isPaymentLinkExpired(existingPayment)) {
          this.logger.log(
            `Found existing payment with expired payment link for paymentReferenceId: ${paymentReferenceId}, will create new payment link`,
          );
          // Continue to create new payment link below
        } else {
          this.logger.log(
            `Found existing non-failed payment with valid payment link for paymentReferenceId: ${paymentReferenceId}, returning existing payment link`,
          );
          return this.mapToPaymentResponse(existingPayment);
        }
      }

      // Create payment record in database
      const paymentData: Partial<Payment> = {
        entityId,
        entityType,
        paymentType,
        amount,
        currency,
        paymentReferenceId,
        status: "pending" as PaymentStatus,
      };

      // Save payment to get paymentId (will be auto-generated by pre-save hook)
      const payment = await this.paymentRepository.create(paymentData);

      this.logger.log(`Payment record created with ID: ${payment.paymentId}`);

      // Call gateway service to handle all gateway-specific logic
      // Note: gateway service uses cartId for PayTabs API, but we store it as paymentReferenceId in DB
      try {
        const gatewayResponse = await this.gatewayService.createPaymentLinkForMember(entity as Member, amount, currency, paymentReferenceId);

        // Normalize gateway response to standard format
        const normalizedResponse = this.gatewayService.normalizeGatewayResponse(gatewayResponse);

        // Calculate payment link expiry time (from config, default 20 minutes)
        const expiryMinutes = this.gatewayService.getPaymentLinkExpiryMinutes();
        const paymentLinkExpiresAt = new Date();
        paymentLinkExpiresAt.setMinutes(paymentLinkExpiresAt.getMinutes() + expiryMinutes - 1);

        // Update payment with gateway response
        const gatewayResponseData = {
          gatewayResponse: {
            ...normalizedResponse,
            createPaymentLinkResponse: gatewayResponse, // Store complete create payment link response
          },
          paymentLink: normalizedResponse.paymentLink || gatewayResponse.paymentLink || gatewayResponse.redirect_url,
          gatewayTransactionId: normalizedResponse.gatewayTransactionId,
          paymentLinkExpiresAt,
          status: "pending" as PaymentStatus,
        };

        await this.paymentRepository.updateOne(
          { paymentId: payment.paymentId },
          { $set: gatewayResponseData },
        );

        // Fetch updated payment
        const updatedPayment = await this.paymentRepository.findByPaymentId(payment.paymentId);

        return this.mapToPaymentResponse(updatedPayment!);
      } catch (gatewayError) {
        // Handle "Duplicate Request" error from PayTabs
        if (
          gatewayError instanceof BadRequestException &&
          gatewayError.message.includes("Duplicate Request")
        ) {
          this.logger.log(`Duplicate request detected for paymentReferenceId: ${paymentReferenceId}, finding existing payment`);

          const existingPayment = await this.handleDuplicateRequest(paymentReferenceId);

          if (existingPayment) {
            return existingPayment;
          }

          // If still no payment found, keep status as pending and re-throw
          // Payment link creation failed, but status remains pending for retry
          this.logger.warn(
            `Duplicate request - existing payment not found. Payment ${payment.paymentId} status remains pending.`,
          );

          // Re-throw the error if we couldn't find an existing payment
          throw gatewayError;
        }

        // For other errors, keep status as pending and re-throw
        // Payment link creation failed, but status remains pending for retry
        this.logger.error(`Payment gateway error for payment ${payment.paymentId}:`, gatewayError);
        this.logger.warn(
          `Payment ${payment.paymentId} status remains pending after gateway error. Payment link creation can be retried.`,
        );

        throw gatewayError;
      }
    } catch (error) {
      this.logger.error(`Error creating payment link for member ${entityId}:`, error);
      if (
        error instanceof BadRequestException ||
        error instanceof InternalServerErrorException
      ) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to create payment link: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Get payment status by entityId and paymentType
   */
  async getPaymentStatusByEntityIdAndPaymentType(entityId: string, paymentType: PaymentType): Promise<PaymentResponseDto> {
    const payment = await this.paymentRepository.findByEntityIdAndPaymentType(entityId, paymentType);
    if (!payment) {
      throw new NotFoundException(`No payment found for entityId ${entityId}`);
    }
    return this.syncAndUpdatePaymentStatus(payment);
  }

  /**
   * Get payment details by entityId and paymentType (without syncing with gateway)
   */
  async getPaymentDetailsByEntityIdAndPaymentType(entityId: string, paymentType: PaymentType): Promise<PaymentResponseDto> {
    const payment = await this.paymentRepository.findByEntityIdAndPaymentType(entityId, paymentType);
    if (!payment) {
      throw new NotFoundException(`No payment found for entityId ${entityId}`);
    }
    return this.mapToPaymentResponse(payment);
  }

  /**
   * Get payment status by paymentId
   */
  async getPaymentStatus(paymentId: string): Promise<PaymentResponseDto> {
    const payment = await this.findPaymentOrThrow(paymentId);
    return this.syncAndUpdatePaymentStatus(payment);
  }

  /**
   * Get payment details by payment ID
   * Fetches payment from database and returns current status and paymentLink
   * Does not sync with gateway - returns current database state
   */
  async getPaymentDetails(paymentId: string): Promise<PaymentResponseDto> {
    const payment = await this.findPaymentOrThrow(paymentId);
    return this.mapToPaymentResponse(payment);
  }

  /**
   * Get payments by payment reference ID
   */
  async getPaymentsByPaymentReferenceId(paymentReferenceId: string): Promise<PaymentResponseDto[]> {
    const payments = await this.paymentRepository.findAll(
      { paymentReferenceId } as any,
      { page: 1, pageSize: 100 },
    );

    return payments.items.map((payment) => this.mapToPaymentResponse(payment));
  }

  /**
   * Refund a payment
   */
  async refundPayment(paymentId: string, dto: RefundPaymentDto): Promise<PaymentResponseDto> {
    const payment = await this.findPaymentOrThrow(paymentId);

    // Allow refunds for paid and partially_refunded payments
    if (payment.status !== "paid" && payment.status !== "partially_refunded") {
      throw new BadRequestException(
        `Cannot refund payment with status: ${payment.status}. Only paid or partially refunded payments can be refunded.`,
      );
    }

    // Calculate total refunded amount
    const totalRefunded = this.calculateTotalRefunded(payment);

    // Check if full amount is already refunded
    if (totalRefunded >= payment.amount) {
      throw new BadRequestException(
        `Cannot process refund: Full amount (${payment.amount} ${payment.currency}) has already been refunded. Total refunded: ${totalRefunded} ${payment.currency}`,
      );
    }

    // Calculate remaining refundable amount
    const remainingRefundable = payment.amount - totalRefunded;
    const refundAmount = dto.amount || remainingRefundable;

    // Check if requested refund amount exceeds remaining refundable amount
    if (refundAmount > remainingRefundable) {
      throw new BadRequestException(
        `Cannot process refund: Requested amount (${refundAmount} ${payment.currency}) exceeds remaining refundable amount (${remainingRefundable} ${payment.currency}). Total refunded so far: ${totalRefunded} ${payment.currency}`,
      );
    }

    try {
      // Process refund through gateway using transaction reference
      const transactionReference = payment.gatewayTransactionId;
      if (!transactionReference) {
        throw new BadRequestException(
          "Cannot process refund: Payment transaction reference not found",
        );
      }

      // Get cart information from payment for refund
      const cartId = payment.paymentReferenceId || "";
      const cartCurrency = payment.currency;
      const cartDescription = `Refund for payment ${payment.paymentId}`;

      const gatewayRefundResponse = await this.gatewayService.processRefund(
        transactionReference,
        cartId,
        cartCurrency,
        payment.amount, // Original cart amount
        cartDescription,
        refundAmount, // Refund amount (can be partial)
      );

      // Create refund record
      const refundInfo = {
        refundId: gatewayRefundResponse.refundId || gatewayRefundResponse.refund_id || uuid(),
        amount: refundAmount,
        currency: payment.currency,
        reason: dto.reason,
        gatewayResponse: gatewayRefundResponse,
        refundedAt: new Date(),
        refundedBy: dto.refundedBy,
      };

      // Calculate new total refunded amount after this refund
      const newTotalRefunded = totalRefunded + refundAmount;

      // Determine payment status based on refund amount
      const newStatus: PaymentStatus =
        newTotalRefunded >= payment.amount
          ? "refunded"
          : "partially_refunded";

      // Update payment with refund info and status
      await this.paymentRepository.addRefund(paymentId, refundInfo);
      await this.paymentRepository.updateOne(
        { paymentId },
        { $set: { status: newStatus } },
      );

      // Fetch updated payment
      const updatedPayment = await this.paymentRepository.findByPaymentId(paymentId);
      return this.mapToPaymentResponse(updatedPayment!);
    } catch (error) {
      this.logger.error(`Error processing refund for payment ${paymentId}:`, error);
      throw new InternalServerErrorException(
        `Failed to process refund: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Helper methods
   */
  private determinePaymentType(entityType: string): Payment["paymentType"] {
    if (entityType === "member") {
      return "membership";
    }
    if (entityType === "event") {
      return "event_registration";
    }
    return "other";
  }

  /**
   * Find payment by ID or throw BadRequestException if not found
   */
  private async findPaymentOrThrow(paymentId: string): Promise<Payment> {
    const payment = await this.paymentRepository.findByPaymentId(paymentId);
    if (!payment) {
      throw new BadRequestException(`Payment with ID ${paymentId} not found`);
    }
    return payment;
  }

  /**
   * Check if payment link is expired
   */
  private isPaymentLinkExpired(payment: Payment): boolean {
    if (!payment.paymentLinkExpiresAt) {
      // If no expiry is set, consider it not expired (backward compatibility)
      return false;
    }
    return new Date() > payment.paymentLinkExpiresAt;
  }

  /**
   * Find payment by transaction reference or payment reference ID
   */
  private async findPaymentByTransactionOrReference(
    transactionRef: string | null,
    paymentReferenceId: string | null,
  ): Promise<Payment> {
    let payment: Payment | null = null;

    if (transactionRef) {
      payment = await this.paymentRepository.findByGatewayTransactionId(transactionRef);
    }

    if (!payment && paymentReferenceId) {
      payment = await this.paymentRepository.findByPaymentReferenceId(paymentReferenceId);
    }

    if (!payment) {
      this.logger.warn(
        `Payment not found - transactionRef: ${transactionRef}, paymentReferenceId: ${paymentReferenceId}`,
      );
      throw new BadRequestException(
        `Payment not found for transaction reference: ${transactionRef || paymentReferenceId}`,
      );
    }

    return payment;
  }

  /**
   * Preserve createPaymentLinkResponse when merging with new normalized gateway response
   */
  private mergeGatewayResponse(
    normalizedResponse: ReturnType<PaytabPaymentGatewayService["normalizeGatewayResponse"]>,
    existingGatewayResponse?: Payment["gatewayResponse"],
  ) {
    return {
      ...normalizedResponse,
      createPaymentLinkResponse: existingGatewayResponse?.createPaymentLinkResponse,
    };
  }

  /**
   * Handle duplicate request error by finding existing payment
   */
  private async handleDuplicateRequest(paymentReferenceId: string): Promise<PaymentResponseDto | null> {
    // Find existing payment by paymentReferenceId
    const existingPaymentByRef = await this.paymentRepository.findByPaymentReferenceId(paymentReferenceId);
    if (existingPaymentByRef && existingPaymentByRef.paymentLink) {
      this.logger.log(`Found existing payment with paymentReferenceId: ${paymentReferenceId}, returning existing payment link`);
      return this.mapToPaymentResponse(existingPaymentByRef);
    }
    return null;
  }

  /**
   * Calculate total refunded amount from existing refunds
   */
  private calculateTotalRefunded(payment: Payment): number {
    if (!payment.refunds || payment.refunds.length === 0) {
      return 0;
    }

    return payment.refunds.reduce((total, refund) => total + refund.amount, 0);
  }

  /**
   * Handle payment callback/webhook
   * This method processes payment gateway callbacks
   * Uses gateway service to process callback data and extract payment information
   * Then fetches status directly from PayTabs API to ensure accuracy
   * Uses the same logic as getPaymentStatus
   */
  async handlePaymentCallback(callbackData: Record<string, any>): Promise<PaymentResponseDto> {
    try {
      this.logger.log(`Processing payment callback: ${JSON.stringify(callbackData)}`);

      // Use gateway service to process callback and extract payment information
      const processedCallback = this.gatewayService.processCallback(callbackData);

      const transactionRef = processedCallback.transactionRef;
      const paymentReferenceId = processedCallback.paymentReferenceId;

      if (!transactionRef && !paymentReferenceId) {
        throw new BadRequestException(
          "Callback data missing: transaction reference (tran_ref) or payment reference ID (cart_id) is required",
        );
      }

      // Find payment by transaction reference (preferred) or payment reference ID (fallback)
      const payment = await this.findPaymentByTransactionOrReference(
        transactionRef,
        paymentReferenceId,
      );

      // Use common logic to sync and update payment status (same as getPaymentStatus)
      // This will fetch status directly from PayTabs API using transaction reference
      // to ensure we have the latest status, even though callback data is available
      const response = await this.syncAndUpdatePaymentStatus(payment);

      this.logger.log(
        `Payment ${payment.paymentId} status updated via callback`,
      );

      return response;
    } catch (error) {
      this.logger.error(`Error processing payment callback:`, error);
      if (
        error instanceof BadRequestException ||
        error instanceof InternalServerErrorException
      ) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to process payment callback: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }

  /**
   * Common method to sync payment status with gateway and update payment
   * Used by both getPaymentStatus and handlePaymentCallback
   * Always fetches status directly from PayTabs API using transaction reference
   */
  private async syncAndUpdatePaymentStatus(payment: Payment): Promise<PaymentResponseDto> {
    const transactionReference = payment.gatewayTransactionId;

    // If no transaction reference, we can't sync with gateway
    if (!transactionReference) {
      this.logger.warn(
        `Cannot sync payment ${payment.paymentId}: No transaction reference found`,
      );
      const fresh = await this.paymentRepository.findByPaymentId(payment.paymentId);
      return this.mapToPaymentResponse(fresh || payment);
    }

    try {
      // Fetch latest status directly from PayTabs API
      const rawGatewayStatus = await this.gatewayService.getPaymentStatus(transactionReference);

      // Check for "Transaction not found" error (code 113)
      // PayTabs returns: { code: 113, message: "ErrorCode = 2000, ErrorMessage=Transaction not found" }
      const isTransactionNotFound = 
        rawGatewayStatus.code === 113 ||
        rawGatewayStatus?.code === "113" ||
        (rawGatewayStatus.message && rawGatewayStatus.message.includes("Transaction not found")) ||
        (rawGatewayStatus.paymentResult?.code === 113) ||
        (rawGatewayStatus.paymentResult?.message && rawGatewayStatus.paymentResult.message.includes("Transaction not found"));

      // If transaction not found, only mark as failed if payment link is expired
      if (isTransactionNotFound) {
        const isExpired = this.isPaymentLinkExpired(payment);
        if (isExpired) {
          this.logger.log(
            `Transaction not found and payment link expired for ${payment.paymentId}, marking as failed`,
          );
          
          // Normalize gateway response to include error details
          const normalizedResponse = this.gatewayService.normalizeGatewayResponse(rawGatewayStatus);
          const updatedGatewayResponse = this.mergeGatewayResponse(
            normalizedResponse,
            payment.gatewayResponse,
          );

          // Update payment status to failed
          await this.paymentRepository.updateOne(
            { paymentId: payment.paymentId },
            {
              $set: {
                status: "failed" as PaymentStatus,
                gatewayResponse: updatedGatewayResponse,
                gatewayTransactionId: updatedGatewayResponse.gatewayTransactionId || payment.gatewayTransactionId,
              },
            },
          );

          const updatedPayment = await this.paymentRepository.findByPaymentId(payment.paymentId);
          return this.mapToPaymentResponse(updatedPayment || payment);
        } else {
          // Transaction not found but link not expired - keep current status
          this.logger.warn(
            `Transaction not found but payment link not expired for ${payment.paymentId}, keeping current status`,
          );
          const fresh = await this.paymentRepository.findByPaymentId(payment.paymentId);
          return this.mapToPaymentResponse(fresh || payment);
        }
      }

      // Map gateway status to our payment status
      const mappedStatus = this.gatewayService.mapGatewayStatusToPaymentStatus(
        rawGatewayStatus.status || "pending",
      );

      // Normalize gateway response to include paymentResult
      const normalizedResponse = this.gatewayService.normalizeGatewayResponse(rawGatewayStatus);

      // Preserve existing createPaymentLinkResponse when updating gatewayResponse
      const updatedGatewayResponse = this.mergeGatewayResponse(
        normalizedResponse,
        payment.gatewayResponse,
      );

      // Update payment status and gateway response
      const statusUpdate: any = mappedStatus && mappedStatus !== payment.status
        ? {
          status: mappedStatus,
          gatewayResponse: updatedGatewayResponse,
          gatewayTransactionId: updatedGatewayResponse.gatewayTransactionId || payment.gatewayTransactionId,
        }
        : {
          gatewayResponse: updatedGatewayResponse,
          gatewayTransactionId: updatedGatewayResponse.gatewayTransactionId || payment.gatewayTransactionId,
        };

      await this.paymentRepository.updateOne(
        { paymentId: payment.paymentId },
        { $set: statusUpdate },
      );

      // Fetch updated payment
      const updatedPayment = await this.paymentRepository.findByPaymentId(payment.paymentId);
      // If payment is paid/failed and entity is a member, update member's payment status
      if (updatedPayment?.entityType === "member" && updatedPayment?.entityId 
        && (updatedPayment?.status === "paid" || updatedPayment?.status === "failed")) {
        try {
          const result = updatedPayment?.status === "paid" ?
            await this.workflowOrchestrator.completePayment(updatedPayment.entityId, {
              paymentStatus: updatedPayment?.status,
            }) : await this.workflowOrchestrator.resetPayment(updatedPayment.entityId, {
              paymentStatus: updatedPayment?.status,
            });
          if (!result.success) {
            throw new Error(result.error || "Failed to update member payment link");
          }
        } catch (error) {
          // Log but don't fail if member update fails
          this.logger.warn(`Failed to update member payment link: ${error}`);
        }
      }

      return this.mapToPaymentResponse(updatedPayment || payment);
    } catch (error) {
      // Log but don't fail if gateway sync fails
      this.logger.warn(`Failed to sync payment status: ${error}`);
    }

    const updatedPayment = await this.paymentRepository.findByPaymentId(payment.paymentId);
    return this.mapToPaymentResponse(updatedPayment || payment);
  }

  private mapToPaymentResponse(payment: Payment): PaymentResponseDto {
    const refundedAmount = this.calculateTotalRefunded(payment);
    const isExpired = this.isPaymentLinkExpired(payment);
    return {
      paymentId: payment.paymentId,
      status: payment.status,
      paymentLink: payment.paymentLink,
      gatewayTransactionId: payment.gatewayTransactionId,
      paymentReferenceId: payment.paymentReferenceId || "",
      amount: payment.amount,
      currency: payment.currency,
      refundedAmount: refundedAmount > 0 ? refundedAmount : undefined,
      paymentLinkExpiresAt: payment.paymentLinkExpiresAt,
      isPaymentLinkExpired: isExpired,
    };
  }

}

